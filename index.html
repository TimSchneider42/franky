<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Franky: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Franky
   &#160;<span id="projectnumber">0.2.0</span>
   </div>
   <div id="projectbrief">A High-Level Motion API for Franka</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Franky Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md__home_runner_work_franky_franky_README"></a> </p><div align="center"> <img src="https://raw.githubusercontent.com/timschneider42/franky/master/doc/logo.svg?sanitize=true" alt="" style="pointer-events: none;" width="340" class="inline"/> <h3 align="center">High-Level Motion Library for the Franka Emika Robot </h3>
</div><div align="center"> </div> <p><a href="https://github.com/timschneider42/franky/actions"><img src="https://github.com/timschneider42/franky/workflows/CI/badge.svg" alt="CI" style="pointer-events: none;" class="inline"/> </a></p>
<p><a href="https://github.com/timschneider42/franky/actions"><img src="https://github.com/timschneider42/franky/workflows/Publish/badge.svg" alt="Publish" style="pointer-events: none;" class="inline"/> </a></p>
<p><a href="https://github.com/timschneider42/franky/issues"><img src="https://img.shields.io/github/issues/timschneider42/franky.svg" alt="Issues" style="pointer-events: none;" class="inline"/> </a></p>
<p><a href="https://github.com/timschneider42/franky/releases"><img src="https://img.shields.io/github/v/release/timschneider42/franky.svg?include_prereleases&amp;sort=semver" alt="Releases" style="pointer-events: none;" class="inline"/> </a></p>
<p><a href="https://github.com/timschneider42/franky/blob/master/LICENSE"><img src="https://img.shields.io/badge/license-LGPL-green.svg" alt="LGPL" style="pointer-events: none;" class="inline"/> </a> </p>
<p>Franky is a high-level motion library (both C++ and Python) for the Franka Emika robot. It adds a Python wrapper around <a href="https://frankaemika.github.io/docs/libfranka.html">libfranka</a>, while replacing necessary real-time programming with higher-level motion commands. As franky focuses on making real-time trajectory generation easy, it allows the robot to react to unforeseen events.</p>
<h2>Differences to frankx</h2>
<p>Franky is a fork of <a href="https://github.com/pantor/frankx">frankx</a>, though both codebase and functionality differ substantially from frankx by now. In particular, franky provides the following new features/improvements:</p><ul>
<li><a href="#real-time-motion">Motions can be updated asynchronously.</a></li>
<li><a href="#real-time-reactions">Reactions allow for the registration of callbacks instead of just printing to stdout when fired.</a></li>
<li><a href="#robot-state">The robot state is also available during control.</a></li>
<li>A larger part of the libfranka API is exposed to python (e.g.,<code>setCollisionBehavior</code>, <code>setJoinImpedance</code>, and <code>setCartesianImpedance</code>).</li>
<li>Cartesian motion generation handles boundaries in Euler angles properly.</li>
<li><a href="#motion-types">There is a new joint motion type that supports waypoints.</a></li>
<li><a href="#geometry">The signature of <code>Affine</code> changed.</a> <code>Affine</code> does not handle elbow positions anymore. Instead, a new class <code>RobotPose</code> stores both the end-effector pose and optionally the elbow position.</li>
<li>The <code>MotionData</code> class does not exist anymore. Instead, reactions and other settings moved to <code>Motion</code>.</li>
<li><a href="#real-time-reactions">The <code>Measure</code> class allows for arithmetic operations.</a></li>
<li>Exceptions caused by libfranka are raised properly instead of being printed to stdout.</li>
</ul>
<h2>Installation</h2>
<p>To start using franky with Python and libfranka <em>0.9.0</em>, just install it via </p><div class="fragment"><div class="line">pip install franky-panda</div>
</div><!-- fragment --><p>Franky is based on <a href="https://github.com/frankaemika/libfranka">libfranka</a>, <a href="https://eigen.tuxfamily.org">Eigen</a> for transformation calculations and <a href="https://github.com/pybind/pybind11">pybind11</a> for the Python bindings. Franky uses the <a href="https://ruckig.com">Ruckig</a> Community Version for Online Trajectory Generation (OTG). As the Franka is quite sensitive to acceleration discontinuities, it requires constrained jerk for all motions. After installing the dependencies (the exact versions can be found below), you can build and install franky via</p>
<div class="fragment"><div class="line">git clone --recurse-submodules git@github.com:timschneider42/franky.git</div>
<div class="line">cd franky</div>
<div class="line">mkdir -p build</div>
<div class="line">cd build</div>
<div class="line">cmake -DBUILD_TYPE=Release ..</div>
<div class="line">make</div>
<div class="line">make install</div>
</div><!-- fragment --><p>To use franky, you can also include it as a subproject in your parent CMake via <code>add_subdirectory(franky)</code> and then <code>target_link_libraries(&lt;target&gt; libfranky)</code>. If you need only the Python module, you can install franky via</p>
<div class="fragment"><div class="line">pip install .</div>
</div><!-- fragment --><p>Make sure that the built library can be found from Python by adapting your Python Path.</p>
<h4>Using Docker</h4>
<p>To use franky within Docker we have supplied a <a href="docker/Dockerfile">Dockerfile</a> which you currently need to build yourself:</p>
<div class="fragment"><div class="line">git clone https://github.com/timschneider42/franky.git</div>
<div class="line">cd franky/</div>
<div class="line">docker build -t franky --build-arg libfranka_version=0.7.0 -f docker/Dockerfile .</div>
</div><!-- fragment --><p>To use another version of libfranka than the default (v.0.7.0) simply change the build argument. Then, to run the container simply:</p>
<div class="fragment"><div class="line">docker run -it --rm --network=host --privileged franky</div>
</div><!-- fragment --><p>The container requires access to the host machines network <em>and</em> elevated user rights to allow the docker user to set RT capabilities of the processes run from within it.</p>
<h2>Tutorial</h2>
<p>Franky comes with both a C++ and Python API that differ only regarding real-time capability. We will introduce both languages next to each other. In your C++ project, just include <code>include &lt;franky/franky.hpp&gt;</code> and link the library. For Python, just <code>import franky</code>. As a first example, only four lines of code are needed for simple robotic motions.</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">#include &lt;franky/franky.hpp&gt;</div>
<div class="line">using namespace franky;</div>
<div class="line"> </div>
<div class="line">// Connect to the robot with the FCI IP address</div>
<div class="line">Robot robot(&quot;172.16.0.2&quot;);</div>
<div class="line"> </div>
<div class="line">// Reduce velocity and acceleration of the robot</div>
<div class="line">robot.setDynamicRel(0.05);</div>
<div class="line"> </div>
<div class="line">// Move the end-effector 20cm in positive x-direction</div>
<div class="line">auto motion = LinearMotion(RobotPose(Affine({0.2, 0.0, 0.0}), 0.0), ReferenceType::Relative);</div>
<div class="line"> </div>
<div class="line">// Finally move the robot</div>
<div class="line">robot.move(motion);</div>
</div><!-- fragment --><p>The corresponding program in Python is </p><div class="fragment"><div class="line">from franky import Affine, LinearMotion, Robot, ReferenceType</div>
<div class="line"> </div>
<div class="line">robot = Robot(&quot;172.16.0.2&quot;)</div>
<div class="line">robot.set_dynamic_rel(0.05)</div>
<div class="line"> </div>
<div class="line">motion = LinearMotion(Affine([0.2, 0.0, 0.0]), ReferenceType.Relative)</div>
<div class="line">robot.move(motion)</div>
</div><!-- fragment --><p>Furthermore, we will introduce methods for geometric calculations, for moving the robot according to different motion types, how to implement real-time reactions and changing waypoints in real time as well as controlling the gripper.</p>
<h3>Geometry</h3>
<p><code><a class="el" href="namespacefranky.html#afab9faf133666ada543b15236a8c4b5f">franky.Affine</a></code> is a python wrapper for <a href="https://eigen.tuxfamily.org/dox/group__TutorialGeometry.html">Eigen::Affine3d</a>. It is used for Cartesian poses, frames and transformation. franky adds its own constructor, which takes a position and a quaternion as inputs: </p><div class="fragment"><div class="line">import math</div>
<div class="line">from scipy.spatial.transform import Rotation</div>
<div class="line">from franky import Affine</div>
<div class="line"> </div>
<div class="line">z_translation = Affine([0.0, 0.0, 0.5])</div>
<div class="line"> </div>
<div class="line">quat = Rotation.from_euler(&quot;xyz&quot;, [0, 0, math.pi / 2]).as_quat()</div>
<div class="line">z_rotation = Affine([0.0, 0.0, 0.0], quat)</div>
<div class="line"> </div>
<div class="line">combined_transformation = z_translation * z_rotation</div>
</div><!-- fragment --><p>In all cases, distances are in [m] and rotations in [rad].</p>
<h3>Robot</h3>
<p>We wrapped most of the libfanka API (including the RobotState or ErrorMessage) for Python. Moreover, we added methods to adapt the dynamics of the robot for all motions. The <code>rel</code> name denotes that this a factor of the maximum constraints of the robot. </p><div class="fragment"><div class="line">from franky import Robot</div>
<div class="line"> </div>
<div class="line">robot = Robot(&quot;172.16.0.2&quot;)</div>
<div class="line"> </div>
<div class="line"># Recover from errors</div>
<div class="line">robot.recover_from_errors()</div>
<div class="line"> </div>
<div class="line"># Set velocity, acceleration and jerk to 5% of the maximum</div>
<div class="line">robot.set_dynamic_rel(0.05)</div>
<div class="line"> </div>
<div class="line"># Alternatively, you can define each constraint individually</div>
<div class="line">robot.velocity_rel = 0.2</div>
<div class="line">robot.acceleration_rel = 0.1</div>
<div class="line">robot.jerk_rel = 0.01</div>
<div class="line"> </div>
<div class="line"># Get the current pose</div>
<div class="line">current_pose = robot.current_pose</div>
</div><!-- fragment --><h3>Robot State</h3>
<p>The robot state can be retrieved by calling the following methods:</p>
<ul>
<li><code>state</code>: Return an object of the <code>franky.RobotState</code> class which contains most of the same attributes, under the same name, as the libfranka <a href="https://frankaemika.github.io/libfranka/structfranka_1_1RobotState.html">franka::RobotState</a> definition.</li>
<li><code>current_pose</code>: Return a 3D Affine transformation object of the measured end effector pose in base frame (alias for <a href="https://frankaemika.github.io/libfranka/structfranka_1_1RobotState.html#a193781d47722b32925e0ea7ac415f442">franka::RobotState::O_T_EE</a>).</li>
<li><code>current_joint_positions</code>: Return a sequence of the manipulator arm's 7-joint positions (alias for <a href="https://frankaemika.github.io/libfranka/structfranka_1_1RobotState.html#ade3335d1ac2f6c44741a916d565f7091">franka::RobotState::q</a>).</li>
</ul>
<div class="fragment"><div class="line">robot = Robot(<span class="stringliteral">&quot;172.16.0.2&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Get the current state</span></div>
<div class="line">state = robot.state</div>
<div class="line">pose = robot.current_pose</div>
<div class="line">joint_positions = robot.current_joint_positions</div>
</div><!-- fragment --><h3>Motion Types</h3>
<p>Franky defines a number of different motion types. In python, you can use them as follows: </p><div class="fragment"><div class="line">import math</div>
<div class="line">from scipy.spatial.transform import Rotation</div>
<div class="line">from franky import JointPositionMotion, JointWaypointMotion, JointWaypoint, JointPositionStopMotion, LinearMotion, CartesianWaypointMotion, CartesianWaypoint, Affine, RobotPose, ReferenceType, CartesianPoseStopMotion</div>
<div class="line"> </div>
<div class="line"># A point-to-point motion in the joint space</div>
<div class="line">m1 = JointPositionMotion([-1.8, 1.1, 1.7, -2.1, -1.1, 1.6, -0.4])</div>
<div class="line"> </div>
<div class="line"># Generalization of JointPositionMotion that allows for multiple waypoints</div>
<div class="line">m2 = JointWaypointMotion([</div>
<div class="line">    JointWaypoint([-1.8, 1.1, 1.7, -2.1, -1.1, 1.6, -0.4]),</div>
<div class="line">    JointWaypoint([-1.7, 1.2, 1.8, -2.0, -1.0, 1.7, -0.3]),</div>
<div class="line">    JointWaypoint([-1.9, 1.0, 1.6, -2.2, -1.2, 1.5, -0.5])</div>
<div class="line">])</div>
<div class="line"> </div>
<div class="line"># Stop the robot</div>
<div class="line">m3 = JointPositionStopMotion()</div>
<div class="line"> </div>
<div class="line"># A linear motion in cartesian space</div>
<div class="line">quat = Rotation.from_euler(&quot;xyz&quot;, [0, 0, math.pi / 2]).as_quat()</div>
<div class="line">m4 = LinearMotion(Affine([0.2, -0.4, 0.3], quat))</div>
<div class="line">m5 = LinearMotion(RobotPose(Affine([0.2, -0.4, 0.3], quat), elbow_position=1.7)) # With target elbow angle</div>
<div class="line"> </div>
<div class="line"># A linear motion in cartesian space relative to the initial position</div>
<div class="line"># (Note that this motion is relative both in position and orientation. Hence, when the robot&#39;s end-effector is oriented</div>
<div class="line"># differently, it will move in a different direction)</div>
<div class="line">m6 = LinearMotion(Affine([0.2, 0.0, 0.0]), ReferenceType.Relative)</div>
<div class="line"> </div>
<div class="line"># Generalization of LinearMotion that allows for multiple waypoints</div>
<div class="line">m7 = CartesianWaypointMotion([</div>
<div class="line">  CartesianWaypoint(RobotPose(Affine([0.2, -0.4, 0.3], quat), elbow_position=1.7)),</div>
<div class="line">  # The following waypoint is relative to the prior one and 50% slower</div>
<div class="line">  CartesianWaypoint(Affine([0.2, 0.0, 0.0]), ReferenceType.Relative, velocity_rel=0.5)</div>
<div class="line">])</div>
<div class="line"> </div>
<div class="line"># Stop the robot. The difference of JointPositionStopMotion to CartesianPoseStopMotion is that JointPositionStopMotion</div>
<div class="line"># stops the robot in joint position control mode while CartesianPoseStopMotion stops it in cartesian pose control mode.</div>
<div class="line"># The difference becomes relevant when asynchronous move commands are being sent (see below).</div>
<div class="line">m8 = CartesianPoseStopMotion()</div>
</div><!-- fragment --><p>Every motion and waypoint type allows to adapt the dynamics (velocity, acceleration and jerk) by setting the respective <code>velocity_rel</code>, <code>acceleration_rel</code>, and <code>jerk_rel</code> parameters.</p>
<p>The real robot can be moved by applying a motion to the robot using <code>move</code>: </p><div class="fragment"><div class="line">robot.move(m1)</div>
<div class="line">robot.move(m2)</div>
</div><!-- fragment --><h3>Real-Time Reactions</h3>
<p>By adding reactions to the motion data, the robot can react to unforeseen events. In the Python API, you can define conditions by using a comparison between a robot's value and a given threshold. If the threshold is exceeded, the reaction fires. </p><div class="fragment"><div class="line">from franky import LinearMotion, Affine, ReferenceType, Measure, Reaction</div>
<div class="line"> </div>
<div class="line">motion = LinearMotion(Affine([0.0, 0.0, 0.1]), ReferenceType.Relative)  # Move down 10cm</div>
<div class="line"> </div>
<div class="line">reaction_motion = LinearMotion(Affine([0.0, 0.0, 0.01]), ReferenceType.Relative)  # Move up for 1cm</div>
<div class="line"> </div>
<div class="line"># Trigger reaction if the Z force is greater than 30N</div>
<div class="line">reaction = Reaction(Measure.FORCE_Z &gt; 30.0, reaction_motion)</div>
<div class="line">motion.add_reaction(reaction)</div>
<div class="line"> </div>
<div class="line">robot.move(motion)</div>
</div><!-- fragment --><p>Possible values to measure are</p><ul>
<li><code>Measure.FORCE_X,</code> <code>Measure.FORCE_Y,</code> <code>Measure.FORCE_Z</code>: Force in X, Y and Z direction</li>
<li><code>Measure.REL_TIME</code>: Time in seconds since the current motion started</li>
<li><code>Measure.ABS_TIME</code>: Time in seconds since the initial motion started</li>
</ul>
<p>The difference between <code>Measure.REL_TIME</code> and <code>Measure.ABS_TIME</code> is that <code>Measure.REL_TIME</code> is reset to zero whenever a new motion starts (either by calling <code>Robot.move</code> or as a result of a triggered <code>Reaction</code>). <code>Measure.ABS_TIME</code>, on the other hand, is only reset to zero when a motion terminates regularly without being interrupted and the robot stops moving. Hence, <code>Measure.ABS_TIME</code> measures the total time in which the robot has moved without interruption.</p>
<p><code>Measure</code> values support all classical arithmetic operations, like addition, subtraction, multiplication, division, and exponentiation (both as base and exponent). </p><div class="fragment"><div class="line">normal_force = (Measure.FORCE_X ** 2 + Measure.FORCE_Y ** 2 + Measure.FORCE_Z ** 2) ** 0.5</div>
</div><!-- fragment --><p>With arithmetic comparisons, conditions can be generated. </p><div class="fragment"><div class="line">normal_force_within_bounds = normal_force &lt; 30.0</div>
<div class="line">time_up = Measure.ABS_TIME &gt; 10.0</div>
</div><!-- fragment --><p>Conditions support negation, conjunction (and), and disjunction (or): </p><div class="fragment"><div class="line">abort = ~normal_force_within_bounds | time_up</div>
<div class="line">fast_abort = ~normal_force_within_bounds | time_up</div>
</div><!-- fragment --><p>To check whether a reaction has fired, a callback can be attached: </p><div class="fragment"><div class="line">from franky import RobotState</div>
<div class="line"> </div>
<div class="line">def reaction_callback(robot_state: RobotState, rel_time: float, abs_time: float):</div>
<div class="line">    print(f&quot;Reaction fired at {abs_time}.&quot;)</div>
<div class="line"> </div>
<div class="line">reaction.register_callback(reaction_callback)</div>
</div><!-- fragment --><p>Note that these callbacks are not executed in the control thread since they would otherwise block it. Instead, they are put in a queue and executed by another thread. While this scheme ensures that the control thread can always run, it cannot prevent that the queue grows indefinitely when the callbacks take more time to execute than it takes for new callbacks to be queued. Hence, callbacks might be executed significantly after their respective reaction has fired if they are triggered in rapid succession or take a long time to execute.</p>
<p>In C++ you can additionally use lambdas to define more complex behaviours: </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">auto motion = LinearMotion(RobotPose(Affine({0.0, 0.0, 0.2}), 0.0), ReferenceType::Relative);</div>
<div class="line"> </div>
<div class="line">// Stop motion if force is over 10N</div>
<div class="line">auto stop_motion = StopMotion&lt;franka::CartesianPose&gt;()</div>
<div class="line"> </div>
<div class="line">motion</div>
<div class="line">  .addReaction(</div>
<div class="line">    Reaction(</div>
<div class="line">      Measure::ForceZ() &gt; 10.0,  // [N],</div>
<div class="line">      stop_motion))</div>
<div class="line">  .addReaction(</div>
<div class="line">    Reaction(</div>
<div class="line">      Condition(</div>
<div class="line">        [](const franka::RobotState&amp; state, double rel_time, double abs_time) {</div>
<div class="line">          // Lambda condition</div>
<div class="line">          return state.current_errors.self_collision_avoidance_violation;</div>
<div class="line">        }),</div>
<div class="line">      [](const franka::RobotState&amp; state, double rel_time, double abs_time) {</div>
<div class="line">        // Lambda reaction motion generator</div>
<div class="line">        // (we are just returning a stop motion, but there could be arbitrary </div>
<div class="line">        // logic here for generating reaction motions)</div>
<div class="line">        return StopMotion&lt;franka::CartesianPose&gt;();</div>
<div class="line">      })</div>
<div class="line">    ));</div>
<div class="line"> </div>
<div class="line">robot.move(motion)</div>
</div><!-- fragment --><h3>Real-Time Motion</h3>
<p>By setting the <code>asynchronous</code> parameter of <code>Robot.move</code> to <code>True</code>, the function does not block until the motion finishes. Instead, it returns immediately and, thus, allows the main thread to set new motions asynchronously. </p><div class="fragment"><div class="line">import time</div>
<div class="line">from franky import Affine, LinearMotion, Robot, ReferenceType</div>
<div class="line"> </div>
<div class="line">robot = Robot(&quot;172.16.0.2&quot;)</div>
<div class="line">robot.set_dynamic_rel(0.05)</div>
<div class="line"> </div>
<div class="line">motion1 = LinearMotion(Affine([0.2, 0.0, 0.0]), ReferenceType.Relative)</div>
<div class="line">robot.move(motion1, asynchronous=True)</div>
<div class="line"> </div>
<div class="line">time.sleep(0.5)</div>
<div class="line">motion2 = LinearMotion(Affine([0.2, 0.0, 0.0]), ReferenceType.Relative)</div>
<div class="line">robot.move(motion2, asynchronous=True)</div>
</div><!-- fragment --><p>By calling <code>Robot.join_motion</code> the main thread can be synchronized with the motion thread, as it will block until the robot finishes its motion. </p><div class="fragment"><div class="line">robot.join_motion()</div>
</div><!-- fragment --><p>Note that when exceptions occur during the asynchronous execution of a motion, they will not be thrown immediately. Instead, the control thread stores the exception and terminates. The next time <code>Robot.join_motion</code> or <code>Robot.move</code> are called, they will throw the stored exception in the main thread. Hence, after an asynchronous motion has finished, make sure to call <code>Robot.join_motion</code> to ensure being notified of any exceptions that occurred during the motion.</p>
<h3>Gripper</h3>
<p>In the <code><a class="el" href="classfranky_1_1_gripper.html">franky::Gripper</a></code> class, the default gripper force and gripper speed can be set. Then, additionally to the libfranka commands, the following helper methods can be used:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">auto gripper = Gripper(&quot;172.16.0.2&quot;);</div>
<div class="line"> </div>
<div class="line">// These are the default values</div>
<div class="line">gripper.gripper_speed = 0.02; // [m/s]</div>
<div class="line">gripper.gripper_force = 20.0; // [N]</div>
<div class="line"> </div>
<div class="line">// Preshape gripper before grasp, use the given speed</div>
<div class="line">gripper.move(50.0); // [mm]</div>
<div class="line"> </div>
<div class="line">// Grasp an object of unknown width</div>
<div class="line">is_grasping = gripper.clamp();</div>
<div class="line"> </div>
<div class="line">// Do something</div>
<div class="line">is_grasping &amp;= gripper.isGrasping();</div>
<div class="line"> </div>
<div class="line">// Release an object and move to a given distance</div>
<div class="line">if (is_grasping) {</div>
<div class="line">  gripper.release(50.0);</div>
<div class="line">}</div>
</div><!-- fragment --><p>The Python API is straight-forward for the Gripper class.</p>
<h3>Kinematics</h3>
<p>Franky includes a rudimentary, non-realtime-capable forward and inverse kinematics.</p>
<div class="fragment"><div class="line">from franky import Kinematics, NullSpaceHandling, Affine</div>
<div class="line"> </div>
<div class="line"># Some initial joint configuration</div>
<div class="line">q = [-1.45549, 1.15401, 1.50061, -2.30909, -1.3141, 1.9391, 0.02815]</div>
<div class="line"> </div>
<div class="line"># Calculate the forward kinematics</div>
<div class="line">x = Kinematics.forward(q)</div>
<div class="line">print(f&quot;Effector position: {x}&quot;)</div>
<div class="line"> </div>
<div class="line"># Define new target position</div>
<div class="line">x_new = Affine([0.1, 0.0, 0.0]) * x</div>
<div class="line"> </div>
<div class="line"># Franka has 7 DoFs, so what to do with the remaining Null space?</div>
<div class="line">null_space = NullSpaceHandling(2, 1.4) # Set elbow joint to 1.4</div>
<div class="line"> </div>
<div class="line"># Inverse kinematic with target, initial joint angles, and Null space configuration</div>
<div class="line">q_new = Kinematics.inverse(x_new.vector(), q, null_space)</div>
<div class="line"> </div>
<div class="line">print(f&quot;New position: {x_new}&quot;)</div>
<div class="line">print(f&quot;New joints: {q_new}&quot;)</div>
</div><!-- fragment --><h2>Documentation</h2>
<p>An auto-generated documentation can be found at <a href="https://timschneider42.github.io/franky/">https://timschneider42.github.io/franky/</a>. Moreover, there are multiple examples for both C++ and Python in the <a href="https://github.com/TimSchneider42/franky/tree/master/examples">examples</a> directory. We will add a more detailed documentation once franky reaches v1.0.</p>
<h2>Development</h2>
<p>Franky is written in C++17 and Python3.7. It is currently tested against following versions</p>
<ul>
<li>Eigen v3.3.7</li>
<li>Libfranka v0.9.0</li>
<li>Pybind11 v2.9.1</li>
<li>Catch2 v2.13 (only for testing)</li>
</ul>
<h2>License</h2>
<p>For non-commercial applications, this software is licensed under the LGPL v3.0. If you want to use franky within commercial applications or under a different license, please contact us for individual agreements. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
